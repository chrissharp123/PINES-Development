<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Retrieving Field Data by Name</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Database Independent Abstraction Layer for C"
HREF="index.html"><LINK
REL="UP"
TITLE="libdbi API Reference"
HREF="reference.html"><LINK
REL="PREVIOUS"
TITLE="Retrieving Field Meta-data"
HREF="reference-field-meta.html"><LINK
REL="NEXT"
TITLE="Retrieving Field Data by Index"
HREF="reference-field-idx.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Database Independent Abstraction Layer for C: libdbi Programmer's Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="reference-field-meta.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. libdbi API Reference</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="reference-field-idx.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="REFERENCE-FIELD"
>4.8. Retrieving Field Data by Name</A
></H1
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-FIELDS"
>4.8.1. dbi_result_get_fields</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2226"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned int <B
CLASS="FSFUNC"
>dbi_result_get_fields</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>format</VAR
>, <VAR
CLASS="PDPARAM"
>...</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch multiple fields from the current result set, using a printf-like syntax. The formatter string specified field names and types, and each field's associated destination variable is passed as an argument following the format string. Fields in the formatter string are separated by spaces, and follow the format <TT
CLASS="LITERAL"
>"a.%b"</TT
>, where "a" is the name of the field, and "b" is the field type specifier. Make sure you pass the destination variables' memory addresses by prepending the &amp; operator to each variable's name.</P
><P
><EM
>Field type specifiers:</EM
></P
><P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>%c / %uc</TT
>: A signed/unsigned character (1-byte)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%h / %uh</TT
>: A signed/unsigned short integer (2-byte)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%l / %ul</TT
>: A signed/unsigned integer (4-byte)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%i / %ui</TT
>: A signed/unsigned integer (4-byte)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%L / %uL</TT
>: A signed/unsigned long long integer (8-byte)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%f</TT
>: A floating point number</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%d</TT
>: A double-precision number</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%s</TT
>: A read-only string</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%S</TT
>: A local copy of a string (must be freed by program)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%b</TT
>: A read-only pointer to binary data</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%B</TT
>: A local copy of binary data (must be freed by program)</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%m</TT
>: A time_t value representing a DATE and/or TIME</P
></LI
></UL
><P
><EM
>Example usage</EM
>: <TT
CLASS="LITERAL"
>dbi_result_get_fields(result, "idnum.%ul lastname.%s", &amp;id_number, &amp;name)</TT
></P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>format</TT
>: The field format string as described above.</P
><P
><TT
CLASS="LITERAL"
>ARG</TT
>: (...) Pointers to the destination variables corresponding with each field in the format string.</P
></DD
><DT
>Returns</DT
><DD
><P
>The number of fields fetched, or DBI_FIELD_ERROR if there was an error. If an invalid field name was specified it will not raise an error, and the other fetched fields will work as usual.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-FIELDS"
>4.8.2. dbi_result_bind_fields</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2296"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned int <B
CLASS="FSFUNC"
>dbi_result_bind_fields</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>format</VAR
>, <VAR
CLASS="PDPARAM"
>...</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind multiple fields in the current result set, using a printf-like syntax. See <A
HREF="reference-field.html#DBI-RESULT-GET-FIELDS"
>dbi_result_get_fields</A
> for a detailed explanation of the syntax.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>format</TT
>: The field format string as described above.</P
><P
><TT
CLASS="LITERAL"
>ARG</TT
>: (...) Pointers to the destination variables corresponding with each field in the format string.</P
></DD
><DT
>Returns</DT
><DD
><P
>The number of field binding set up, or DBI_FIELD_ERROR if there was an error.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-CHAR"
>4.8.3. dbi_result_get_char</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2324"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>signed char <B
CLASS="FSFUNC"
>dbi_result_get_char</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a character (a 1-byte signed integer). This is the default for the "char" type on the x86 platform, as well as on Mac OS X.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-UCHAR"
>4.8.4. dbi_result_get_uchar</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2348"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned <B
CLASS="FSFUNC"
>char dbi_result_get_uchar</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains an unsigned character (1-byte unsigned integer). This is the default for the "char" type on Linux for PowerPC.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-SHORT"
>4.8.5. dbi_result_get_short</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2372"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>short <B
CLASS="FSFUNC"
>dbi_result_get_short</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>const char *fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a short integer (2-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-USHORT"
>4.8.6. dbi_result_get_ushort</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2396"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned short <B
CLASS="FSFUNC"
>dbi_result_get_ushort</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains an unsigned short integer (2-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-INT"
>4.8.7. dbi_result_get_int</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2420"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_get_int</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains an integer (4-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-UINT"
>4.8.8. dbi_result_get_uint</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2444"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned int <B
CLASS="FSFUNC"
>dbi_result_get_uint</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains an unsigned integer (4-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-LONG"
>4.8.9. dbi_result_get_long</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2468"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_get_long</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>This is the same as <A
HREF="reference-field.html#DBI-RESULT-GET-INT"
>dbi_result_get_int</A
>. The use of this function is deprecated as the name implies the wrong return type on 64-bit platforms.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-ULONG"
>4.8.10. dbi_result_get_ulong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2480"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned int <B
CLASS="FSFUNC"
>dbi_result_get_ulong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>This is the same as <A
HREF="reference-field.html#DBI-RESULT-GET-UINT"
>dbi_result_get_uint</A
>. The use of this function is deprecated as the name implies the wrong return type on 64-bit platforms.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-LONGLONG"
>4.8.11. dbi_result_get_longlong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2492"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>long long <B
CLASS="FSFUNC"
>dbi_result_get_longlong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a long long integer (8-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-ULONGLONG"
>4.8.12. dbi_result_get_ulonglong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2516"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned long long <B
CLASS="FSFUNC"
>dbi_result_get_ulonglong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains an unsigned long long integer (8-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-FLOAT"
>4.8.13. dbi_result_get_float</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2540"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>float <B
CLASS="FSFUNC"
>dbi_result_get_float</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a floating-point number.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, which contains a fractional number, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-DOUBLE"
>4.8.14. dbi_result_get_double</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2564"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>double <B
CLASS="FSFUNC"
>dbi_result_get_double</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a double-precision fractional number.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, or 0 (zero) if an error occurs. In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME..</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-STRING"
>4.8.15. dbi_result_get_string</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2588"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const char *<B
CLASS="FSFUNC"
>dbi_result_get_string</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a zero-terminated string.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field, which is a zero-terminated string. If the field contains a NULL value, the function returns a NULL pointer. The string may not be modified, and may not necessarily persist between row fetches. In case of an error, this function returns the string "ERROR". In the latter case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-STRING-COPY"
>4.8.16. dbi_result_get_string_copy</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2612"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *<B
CLASS="FSFUNC"
>dbi_result_get_string_copy</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains a zero-terminated string, and return it in an allocated buffer.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field as a zero-terminated allocated string. If the field contains a NULL value, the function returns a NULL pointer, and no memory is allocated. The newly allocated string may be modified by the host program, but the program is responsible for freeing the string. In case of an error, this function returns an allocated string reading "ERROR". In that case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-BINARY"
>4.8.17. dbi_result_get_binary</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2636"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>const unsigned char *<B
CLASS="FSFUNC"
>dbi_result_get_binary</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains binary data.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field. The binary data may contain zero bytes and non-printable characters. Use <A
HREF="reference-field-meta.html#DBI-RESULT-GET-FIELD-LENGTH"
>dbi_result_get_field_length</A
> or <A
HREF="reference-field-meta.html#DBI-RESULT-GET-FIELD-LENGTH-IDX"
>dbi_result_get_field_length_idx</A
> to determine the number of bytes contained in the resulting binary string. The data may not be modified, and may not necessarily persist between row fetches. If the field contains a NULL value, the function returns a NULL pointer. In case of an error, this function returns the string "ERROR". In that case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-BINARY-COPY"
>4.8.18. dbi_result_get_binary_copy</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2662"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>unsigned char *<B
CLASS="FSFUNC"
>dbi_result_get_binary_copy</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the speficied field, which contains binary data, and return it in an allocated buffer.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field. The binary data may contain zero bytes and non-printable characters. Use <A
HREF="reference-field-meta.html#DBI-RESULT-GET-FIELD-LENGTH"
>dbi_result_get_field_length</A
> or <A
HREF="reference-field-meta.html#DBI-RESULT-GET-FIELD-LENGTH-IDX"
>dbi_result_get_field_length_idx</A
> to determine the number of bytes contained in the resulting binary string. The newly allocated memory may be modified by the host program, but the program is responsible for freeing the data. If the field contains a NULL value, the function returns a NULL pointer. In case of an error, this function returns the string "ERROR". In that case the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-GET-DATETIME"
>4.8.19. dbi_result_get_datetime</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2688"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>time_t <B
CLASS="FSFUNC"
>dbi_result_get_datetime</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Fetch the data stored in the specified field, which contains a DATE and/or TIME value.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to fetch.</P
></DD
><DT
>Returns</DT
><DD
><P
>The data stored in the specified field as a time_t value. To convert this into human-readable dates or times, use the C library functions gmtime (3) and localtime (3). In case of an error this function returns 0 (zero) which resolves to the Unix epoch when converted. In case of an error the <A
HREF="errornumbers.html"
>error number</A
> is DBI_ERROR_BADTYPE, DBI_ERROR_BADIDX, or DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-CHAR"
>4.8.20. dbi_result_bind_char</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2712"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_char</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, char *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a character (a 1-byte signed integer). This is the default for the "char" type on the x86 platform, as well as on Mac OS X.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-UCHAR"
>4.8.21. dbi_result_bind_uchar</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2740"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_uchar</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned char *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds an unsigned character (1-byte unsigned integer). This is the default for the "char" type on Linux for PowerPC.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-SHORT"
>4.8.22. dbi_result_bind_short</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2768"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_short</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, short *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a short integer (2-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-USHORT"
>4.8.23. dbi_result_bind_ushort</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2796"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_ushort</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned short *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds an unsigned short integer (2-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-INT"
>4.8.24. dbi_result_bind_int</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2824"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_int</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds an integer (4-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-UINT"
>4.8.25. dbi_result_bind_uint</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2852"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_uint</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds an unsigned long integer (4-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-LONG"
>4.8.26. dbi_result_bind_long</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2880"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_long</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>The same as <A
HREF="reference-field.html#DBI-RESULT-BIND-INT"
>dbi_result_bind_int</A
>. The use of this function is deprecated as the name implies the wrong return type on 64-bit platforms.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-ULONG"
>4.8.27. dbi_result_bind_ulong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2894"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_ulong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>The same as <A
HREF="reference-field.html#DBI-RESULT-BIND-UINT"
>dbi_result_bind_uint</A
>. The use of this function is deprecated as the name implies the wrong return type on 64-bit platforms.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-LONGLONG"
>4.8.28. dbi_result_bind_longlong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2908"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_longlong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, long long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a long long integer (8-byte signed integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-ULONGLONG"
>4.8.29. dbi_result_bind_ulonglong</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2936"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_ulonglong</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned long long *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds an unsigned long long integer (8-byte unsigned integer).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-FLOAT"
>4.8.30. dbi_result_bind_float</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2964"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_float</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, float *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a floating-point number.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-DOUBLE"
>4.8.31. dbi_result_bind_double</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN2992"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_double</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, double *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a double-precision fractional number.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-STRING"
>4.8.32. dbi_result_bind_string</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN3020"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_string</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, const char **<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a string. The string must not be modified.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-BINARY"
>4.8.33. dbi_result_bind_binary</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN3048"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_binary</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, const unsigned char **<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds binary BLOB data. The data must not be modified.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-STRING-COPY"
>4.8.34. dbi_result_bind_string_copy</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN3076"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_string_copy</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, char **<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a string. The newly allocated string may be modified by the host program, but the program is responsible for freeing the string.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-BINARY-COPY"
>4.8.35. dbi_result_bind_binary_copy</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN3104"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_binary_copy</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, unsigned char **<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds binary BLOB data. The newly allocated data may be modified by the host program, but the program is responsible for freeing the data.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="DBI-RESULT-BIND-DATETIME"
>4.8.36. dbi_result_bind_datetime</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN3132"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int <B
CLASS="FSFUNC"
>dbi_result_bind_datetime</B
></CODE
>(dbi_result <VAR
CLASS="PDPARAM"
>Result</VAR
>, const char *<VAR
CLASS="PDPARAM"
>fieldname</VAR
>, time_t *<VAR
CLASS="PDPARAM"
>bindto</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>Bind the specified variable to the specified field, which holds a DATE and/or TIME value.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Arguments</DT
><DD
><P
><TT
CLASS="LITERAL"
>Result</TT
>: The target query result.</P
><P
><TT
CLASS="LITERAL"
>fieldname</TT
>: The name of the field to bind to.</P
><P
><TT
CLASS="LITERAL"
>bindto</TT
>: A pointer to the variable that will be updated with the specified field's value.</P
></DD
><DT
>Returns</DT
><DD
><P
>0 upon success, DBI_BIND_ERROR if there was an error. Possible <A
HREF="errornumbers.html"
>error numbers</A
> are DBI_ERROR_BADPTR, DBI_ERROR_NOMEM, and DBI_ERROR_BADNAME.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="reference-field-meta.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="reference-field-idx.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Retrieving Field Meta-data</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="reference.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Retrieving Field Data by Index</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>