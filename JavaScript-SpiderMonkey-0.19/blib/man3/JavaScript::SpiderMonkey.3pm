.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SpiderMonkey 3pm"
.TH SpiderMonkey 3pm "2007-09-05" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JavaScript::SpiderMonkey \- Perl interface to the JavaScript Engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use JavaScript::SpiderMonkey;
\&
\&    my $js = JavaScript::SpiderMonkey\->new();
\&
\&    $js\->init();  # Initialize Runtime/Context
\&
\&                  # Define a perl callback for a new JavaScript function
\&    $js\->function_set("print_to_perl", sub { print "@_\en"; });
\&
\&                  # Create a new (nested) object and a property
\&    $js\->property_by_path("document.location.href");
\&
\&                  # Execute some code
\&    my $rc = $js\->eval(q!
\&        document.location.href = append("http://", "www.aol.com");
\&
\&        print_to_perl("URL is ", document.location.href);
\&
\&        function append(first, second) {
\&             return first + second;
\&        }
\&    !);
\&
\&        # Get the value of a property set in JS
\&    my $url = $js\->property_get("document.location.href");
\&
\&    $js\->destroy();
.Ve
.SH "INSTALL"
.IX Header "INSTALL"
JavaScript::SpiderMonkey requires Mozilla's readily compiled
SpiderMonkey 1.5 distribution or better. Please check
\&\*(L"SpiderMonkey Installation\*(R".
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JavaScript::SpiderMonkey is a Perl Interface to the
SpiderMonkey JavaScript Engine. It is different from 
Claes Jacobsson's \f(CW\*(C`JavaScript.pm\*(C'\fR in that it offers two
different levels of access:
.IP "[1]" 4
.IX Item "[1]"
A 1:1 mapping of the SpiderMonkey \s-1API\s0 to Perl
.IP "[2]" 4
.IX Item "[2]"
A more Perl-like \s-1API\s0
.PP
This document describes [2], for [1], please check \f(CW\*(C`SpiderMonkey.xs\*(C'\fR.
.SS "\fInew()\fP"
.IX Subsection "new()"
\&\f(CW\*(C`$js = JavaScript::SpiderMonkey\->new()\*(C'\fR creates a new object to work with.
To initialize the \s-1JS\s0 runtime, call \f(CW\*(C`$js\->init()\*(C'\fR afterwards.
.ie n .SS "$js\->\fIdestroy()\fP"
.el .SS "\f(CW$js\fP\->\fIdestroy()\fP"
.IX Subsection "$js->destroy()"
\&\f(CW\*(C`$js\->destroy()\*(C'\fR destroys the current runtime and frees up all memory.
.ie n .SS "$js\->\fIinit()\fP"
.el .SS "\f(CW$js\fP\->\fIinit()\fP"
.IX Subsection "$js->init()"
\&\f(CW\*(C`$js\->init()\*(C'\fR initializes the SpiderMonkey engine by creating a context,
default classes and objects and adding an error reporter.
.ie n .SS "$js\->array_by_path($name)"
.el .SS "\f(CW$js\fP\->array_by_path($name)"
.IX Subsection "$js->array_by_path($name)"
Creates an object of type \fIArray\fR
in the \s-1JS\s0 runtime:
.PP
.Vb 1
\&    $js\->array_by_path("document.form");
.Ve
.PP
will first create an object with the name \f(CW\*(C`document\*(C'\fR (unless
it exists already) and then define a property named \f(CW\*(C`form\*(C'\fR to it,
which is an object of type \fIArray\fR. Therefore, in the \s-1JS\s0 code,
you're going to be able define things like
.PP
.Vb 1
\&    document.form[0] = "value";
.Ve
.ie n .SS "$js\->function_set($name, $funcref, [$obj])"
.el .SS "\f(CW$js\fP\->function_set($name, \f(CW$funcref\fP, [$obj])"
.IX Subsection "$js->function_set($name, $funcref, [$obj])"
Binds a Perl function provided as a coderef (\f(CW$funcref\fR) 
to a newly created \s-1JS\s0 function
named \f(CW$name\fR in \s-1JS\s0 land. 
It's a real function (therefore bound to the global object) if \f(CW$obj\fR
is omitted. However, if \f(CW$obj\fR is ref to
a \s-1JS\s0 object (retrieved via \f(CW\*(C`$js\->object_by_path($path)\*(C'\fR or the like),
the function will be a \fImethod\fR of the specified object.
.PP
.Vb 2
\&    $js\->function_set("write", sub { print @_ });
\&        # write("hello"); // In JS land
\&
\&    $obj = $j\->object_by_path("navigator");
\&    $js\->function_set("write", sub { print @_ }, $obj);
\&        # navigator.write("hello"); // In JS land
.Ve
.ie n .SS "$js\->array_set_element($obj, $idx, $val)"
.el .SS "\f(CW$js\fP\->array_set_element($obj, \f(CW$idx\fP, \f(CW$val\fP)"
.IX Subsection "$js->array_set_element($obj, $idx, $val)"
Sets the element of the array \f(CW$obj\fR
at index position \f(CW$idx\fR to the value \f(CW$val\fR.
\&\f(CW$obj\fR is a reference to an object of type array
(retrieved via \f(CW\*(C`$js\->object_by_path($path)\*(C'\fR or the like).
.ie n .SS "$js\->array_set_element_as_object($obj, $idx, $elobj)"
.el .SS "\f(CW$js\fP\->array_set_element_as_object($obj, \f(CW$idx\fP, \f(CW$elobj\fP)"
.IX Subsection "$js->array_set_element_as_object($obj, $idx, $elobj)"
Sets the element of the array \f(CW$obj\fR
at index position \f(CW$idx\fR to the object \f(CW$elobj\fR
(both \f(CW$obj\fR and \f(CW$elobj\fR have been retrieved 
via \f(CW\*(C`$js\->object_by_path($path)\*(C'\fR or the like).
.ie n .SS "$js\->array_get_element($obj, $idx)"
.el .SS "\f(CW$js\fP\->array_get_element($obj, \f(CW$idx\fP)"
.IX Subsection "$js->array_get_element($obj, $idx)"
Gets the value of of the element at index \f(CW$idx\fR
of the object of type Array \f(CW$obj\fR.
.ie n .SS "$js\->property_by_path($path, $value, [$getter], [$setter])"
.el .SS "\f(CW$js\fP\->property_by_path($path, \f(CW$value\fP, [$getter], [$setter])"
.IX Subsection "$js->property_by_path($path, $value, [$getter], [$setter])"
Sets the specified property of an object in \f(CW$path\fR to the 
value \f(CW$value\fR. \f(CW$path\fR is the full name of the property,
including the object(s) in \s-1JS\s0 land it belongs to:
.PP
.Vb 1
\&    $js\-E<gt>property_by_path("document.location.href", "abc");
.Ve
.PP
This first creates the object \f(CW\*(C`document\*(C'\fR (if it doesn't exist already),
then the object \f(CW\*(C`document.location\*(C'\fR, then attaches the property
\&\f(CW\*(C`href\*(C'\fR to it and sets it to \f(CW"abc"\fR.
.PP
\&\f(CW$getter\fR and \f(CW$setter\fR are coderefs that will be called by 
the JavaScript engine when the respective property's value is
requested or set:
.PP
.Vb 4
\&    sub getter {
\&        my($property_path, $value) = @_;
\&        print "$property_path has value $value\en";
\&    }
\&
\&    sub setter {
\&        my($property_path, $value) = @_;
\&        print "$property_path set to value $value\en";
\&    }
\&
\&    $js\-E<gt>property_by_path("document.location.href", "abc",
\&                              \e&getter, \e&setter);
.Ve
.PP
If you leave out \f(CW$getter\fR and \f(CW$setter\fR, there's going to be no
callbacks triggerd while the properity is set or queried.
If you just want to specify a \f(CW$setter\fR, but no \f(CW$getter\fR,
set the \f(CW$getter\fR to \f(CW\*(C`undef\*(C'\fR.
.ie n .SS "$js\->object_by_path($path, [$newobj])"
.el .SS "\f(CW$js\fP\->object_by_path($path, [$newobj])"
.IX Subsection "$js->object_by_path($path, [$newobj])"
Get a pointer to an object with the path
specified. Create it if it's not there yet.
If \f(CW$newobj\fR is provided, the ref is used to 
bind the existing object to the name in \f(CW$path\fR.
.ie n .SS "$js\->property_get($path)"
.el .SS "\f(CW$js\fP\->property_get($path)"
.IX Subsection "$js->property_get($path)"
Fetch the property specified by the \f(CW$path\fR.
.PP
.Vb 1
\&    my $val = $js\->property_get("document.location.href");
.Ve
.ie n .SS "$js\->eval($code)"
.el .SS "\f(CW$js\fP\->eval($code)"
.IX Subsection "$js->eval($code)"
Runs the specified piece of <$code> in the \s-1JS\s0 engine.
Afterwards, property values of objects previously defined 
will be available via \f(CW\*(C`$j\->property_get($path)\*(C'\fR
and the like.
.PP
.Vb 1
\&    my $rc = $js\->eval("write(\*(Aqhello\*(Aq);");
.Ve
.PP
The method returns \f(CW1\fR on success or else if
there was an error in \s-1JS\s0 land. In case of an error, the \s-1JS\s0
error text will be available in \f(CW$@\fR.
.ie n .SS "$js\->set_max_branch_operations($max_branch_operations)"
.el .SS "\f(CW$js\fP\->set_max_branch_operations($max_branch_operations)"
.IX Subsection "$js->set_max_branch_operations($max_branch_operations)"
Set the maximum number of allowed branch operations. This protects
against infinite loops and guarantees that the eval operation
will terminate.
.SH "SpiderMonkey Installation"
.IX Header "SpiderMonkey Installation"
First, get the latest SpiderMonkey distribution from mozilla.org:
http://www.mozilla.org/js/spidermonkey shows which releases are available.
\&\f(CW\*(C`js\-1.6.tar.gz\*(C'\fR has been proven to work.
.PP
Untar it at the same directory level as you just untarred the 
\&\f(CW\*(C`JavaScript::SpiderMonkey\*(C'\fR distribution you're currently reading.
So, if you're currently in \f(CW\*(C`/my/path/JavaScript\-SpiderMonkey\-v.vv\*(C'\fR, do
this:
.PP
.Vb 3
\&    cp js\-1.6.tar.gz /my/path
\&    cd /my/path
\&    tar zxfv js\-1.6.tar.gz
.Ve
.PP
Then, compile the SpiderMonkey distribution, if you're on Linux, 
just use:
.PP
.Vb 2
\&    cd js/src
\&    make \-f Makefile.ref
.Ve
.PP
It's important that the js and JavaScript\-SpiderMonkey\-v.vv directories
are at the same level:
.PP
.Vb 5
\&    [/my/path]$ ls
\&    JavaScript\-SpiderMonkey\-v.vv
\&    js
\&    js\-1.6.tar.gz
\&    [/my/path]$
.Ve
.PP
(Note that you *can* untar the SpiderMonkey distribution elsewhere,
but, if so, then you need to edit the setting of \f(CW$JSLIBPATH\fR in Makefile.PL).
.PP
Next, you need to copy the shared library file thus constructed
(e.g., libjs.so or js32.dll) to an appropriate directory on your library path.
On Windows, this can also be the directory where the perl executable 
lives. On Unix, this has been shown to work without copying, but this way
you need to keep the compiled binary in the \f(CW\*(C`js\*(C'\fR build directory forever. 
Copying
\&\f(CW\*(C`js/src/Your_OS_DBG.OBJ/libjs.so\*(C'\fR to \f(CW\*(C`/usr/local/lib\*(C'\fR and
making sure that \f(CW\*(C`/usr/local/lib\*(C'\fR is in your \f(CW\*(C`LD_LIBRARY_PATH\*(C'\fR
seems to be safest bet.
.PP
Now, build JavaScript::SpiderMonkey in the standard way:
.PP
.Vb 5
\&    cd JavaScript\-SpiderMonkey\-v.vv
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.SH "E4X SUPPORT"
.IX Header "E4X SUPPORT"
To build JavaScript-SpiderMonkey with E4X (ECMAScript for \s-1XML\s0) support:
.PP
.Vb 1
\&    perl Makefile.PL \-E4X
.Ve
.PP
Please note that E4X support is only supported since SpiderMonkey release 1.6.
.SH "THREAD SAFETY"
.IX Header "THREAD SAFETY"
To build JavaScript-SpiderMonkey when using a thread safe version of SpiderMonkey:
.PP
.Vb 1
\&   perl Makefile.PL \-JS_THREADSAFE
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\&  Mike Schilli, <m at perlmeister dot com>
\&  Thomas Busch, <tbusch at cpan dot org> (current maintainer)
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 2
\&  Copyright (c) 2002\-2005 Mike Schilli
\&  Copyright (c) 2006\-2007 Thomas Busch
.Ve
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
